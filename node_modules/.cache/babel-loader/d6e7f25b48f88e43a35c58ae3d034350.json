{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/home/pc/Documentos/github-repositorio-projeto/src/pages/Dashboard/index.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from 'react';\nimport { Title, Form, Repositories, Error } from './styles';\nimport { FiChevronRight } from 'react-icons/fi';\nimport api from '../../services/api';\nimport logoImg from \"../../assets/images/logotipo.svg\"; //import Repository from '../Repository';\n// Essa interface é a definição dos tipos que existe na api publica do github\n\n/*9º*/\n\nconst Dashboard = () => {\n  _s();\n\n  /*3º*/\n  const [newRepo, setNewRepo] = useState(''); // Estado para armazenar o valor do input\n\n  /*5º*/\n\n  const [repositories, setRepositories] = useState([]); //Vai armazenar os repositórios usando o useState. Foi adicionado o <Repository[]> após o usState porque ele ta pegando o array de repositórios que o setRepositories ta recebendo.\n\n  /*12º*/\n\n  const [inputError, setInputError] = useState('');\n  /*18º*/\n\n  useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n  /*1º*/\n\n  async function hundleAddRepository(event) {\n    //Adição de um novo repositŕoio\n    //Consumir a API do Github buscado\n    //Salvar novo respositório no estado\n\n    /* (event: FormEvent<HTMLFormElement>) junto com o event.preventDefault();\n    Previne o evento de recarregar a página sempre quando clica, nesse caso teve essa extenção maior porque o evento é no form, por isso, teve que importar o FormEvent tambem. Então foi passado um uma tipagem pronta nativo para formulário.\n    */\n    // async é significa função assicrona é necessário para trabalhar com a API.\n    // Quando a função passa a ser async é necessaŕio usar o Promise<void>\n\n    /*2º*/\n    event.preventDefault();\n    /*13º*/\n\n    if (!newRepo) {\n      setInputError('Digite o autor/nome do repositório');\n      return;\n    }\n    /*14º*/\n\n\n    try {\n      // Chamada da API\n\n      /*4º*/\n      const response = await api.get(`repos/${newRepo}`);\n      /*6º*/\n\n      const repository = response.data; // repository está recebendo a informação do response, o response ta armazebando as informações da api. Já o data, seria as informações dos objetos.\n      //A API ta pegando os dados que ta armazenado em: ${newRepo} para assim ser inserido na pesquisa\n      // api.get(`repos/${newRepo}`) Em repos/ é a prévia fixa da URL de pesquisa\n      // O const repository são os dados que precisam ser adicionados ao fim da lista (Próxima etapa do projeto)\n      // Foi adicionado <Repository>, para pegar as informações baseadas na tipagem definina na interface Repository\n\n      /*7º*/\n\n      setRepositories([...repositories, repository]);\n      /*11º*/\n      //Após clicar em pesquisar, o valor de pesquisa inserido no input permanece sendo exibido, para poder limpar e assim, ter uma expeciência mais agradavel de incluir uma nova pesquisa (valor), para isso, precisa chamar o estado nessa função. setNewRepo('');\n\n      setNewRepo('');\n      setInputError('');\n    } catch (error) {\n      setInputError('O autor/nome do repositório não existe');\n    }\n  }\n  /* No input, o valor que vai receber é o value={newRepo}\n  Quando o usuário altera o valor desse input, recebe um evento onChange={(e) => setNewRepo(e.target.value)}\n  */\n\n  /*10º*/\n  //Incluir as tipagens nas informações.\n  //No uso do map, foi adicionado o estado repositories que está recebendo um array e definindo um parametro, e no primeiro intem é importanten adicionar uma Key=\n\n  /*** Tratamento de erros ***/\n\n  /*12º*/\n\n  /*\n  const [inputError, setInputError] = useState('') Precisa ser criado um estado para o tratamento de erros. Foi criado como uma string ('') e não com True ou False porque pode ter mais de uma mensagem de erro.\n  /*13º*/\n\n  /*\n  No inicio da função, será adicionado uma verificação, se o conteúdo da varivavel newRepo está vazio, o sinal de negação antes dele ja vai verificar. Então, newRpo vai receber o ustate setInputError com a seguinte mensagem... ('Digite o autor/nome do repositório')\n  */\n\n  /*14º*/\n\n  /*\n  Todos os itens como:\n  -> const response = await api.get<Repository>(`repos/${newRepo}`);\n  -> const repository = response.data;\n  -> setRepositories([...repositories, repository]);\n  -> setNewRepo('');\n  Serão alocados para dentro de um Try. Se, a vaerificação do response falhar, será apresentado o erro em Catch. No caso optei em deixar catch(error) {seInputError('Erro na busca por esse repositório')}\n  */\n\n  /*15º*/\n\n  /*\n  Foi criado um componente de estilo chamado {inputError && <Error>{inputError}</Error> }. Isso siginifca que se a variavel inputError ta preenchida, é mostrado o imput com a mensagem de erro e o component Error vai estilizar para ser exebido assim. O componente Error foi criado no style do componente Dashboard.\n  */\n\n  /*16º*/\n\n  /*\n  O problema agora é que o erro ele não deixa de exibir após incluir um valor válido, o mesmo problema que teve para limpar o valor após digitado na pesquisa. Para isso não ocorrer, precisa adicionar o estado com uma string vazia.\n  */\n\n  /*17º*/\n\n  /*\n  hasError={!!inputError} está recebendo a varivel/estado vazia. hasError não será reconhecido facilmente no form, por isso precisa ser aplicado diretamente na estilização do form uma prop pra ele. export const Form = styled.form<FormProps>`` e com isso criado uma interface chamada...\n  interface FormProps {\n  hasError: boolean;\n  }\n  Também precisa importar o {css}\n  import styled, {css} from 'styled-components';\n  Para permitir o uso de CSS sentro das aspas ``, se não, não reconheceria o estilo dentro, ele entenderia como um texto simples.\n  Agora é possivel criar um estilo especifico sempre que o status de erro aparecer conforme o objetivo dessa variavel.\n  */\n\n  /*** LocalStorage ***/\n\n  /*O objetivo do LocalStorage será para armazenar os repositórios após a pesquisa do repositório e manter exposto após atualizar a página, ja que sempre ao atualizar, não mostra mais  os repositórios pesquisados.\n  */\n\n  /*18º*/\n\n  /*\n  Uma boa utilidade será o useEffect, ele permite que disparamos uma função sempre que uma varivel mudar.\n  Primeiro será importando import React, {useState, FormEvent, useEffect} from 'react';\n  Depois a declaração será colocada acima da função assicrona da seguinte forma.\n  useEffect(() => {\n  localStorage.setItem('@GithubExplorer:repositories', repositories);\n  }, [repositories]);\n  Onde ta '@GithubExplorer:repositories' foi a nomeação escolhida para identificar qual a aplicação que está sendo armazenada no Local Storange, é adicionado em uma string textual. Só que o LocalStorage não aceira Array e que o argumento do tipo repositories não possivel converter para string, para isso, é necessário converter o tipo para string: JSON.stringify(repositories)\n  useEffect(() => {\n  localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n  */\n\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"img\", {\n      src: logoImg,\n      alt: \"Github Explorer\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 143,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(Title, {\n      children: \"Explore reposit\\xF3rios no Github\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(Form, {\n      hasError: !!inputError,\n      onSubmit: hundleAddRepository,\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        placeholder: \"Digite o nome do reposit\\xF3rio\",\n        value: newRepo,\n        onChange: e => setNewRepo(e.target.value)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 147,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        type: \"submit\",\n        children: \"Pesquisar\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 148,\n        columnNumber: 7\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 146,\n      columnNumber: 5\n    }, this), inputError && /*#__PURE__*/_jsxDEV(Error, {\n      children: inputError\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 152,\n      columnNumber: 18\n    }, this), /*#__PURE__*/_jsxDEV(Repositories, {\n      children: repositories.map(repository => /*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"teste\",\n        children: [/*#__PURE__*/_jsxDEV(\"img\", {\n          src: repository.owner.avatar_url,\n          alt: repository.owner.login\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 156,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: repository.full_name\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 158,\n            columnNumber: 6\n          }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n            children: repository.description\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 159,\n            columnNumber: 7\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 157,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(FiChevronRight, {\n          size: 20\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 161,\n          columnNumber: 9\n        }, this)]\n      }, repository.full_name, true, {\n        fileName: _jsxFileName,\n        lineNumber: 155,\n        columnNumber: 9\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true);\n};\n\n_s(Dashboard, \"oXL56eFXcb8ov2VrZ1WAtC9IDQU=\");\n\n_c = Dashboard;\nexport default Dashboard;\n\nvar _c;\n\n$RefreshReg$(_c, \"Dashboard\");","map":{"version":3,"sources":["/home/pc/Documentos/github-repositorio-projeto/src/pages/Dashboard/index.tsx"],"names":["React","useState","useEffect","Title","Form","Repositories","Error","FiChevronRight","api","Dashboard","newRepo","setNewRepo","repositories","setRepositories","inputError","setInputError","localStorage","setItem","JSON","stringify","hundleAddRepository","event","preventDefault","response","get","repository","data","error","logoImg","e","target","value","map","owner","avatar_url","login","full_name","description"],"mappings":"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","sourcesContent":["import React, {useState, FormEvent, useEffect} from 'react';\nimport {Title, Form, Repositories, Error} from './styles';\nimport {FiChevronRight} from 'react-icons/fi';\nimport api from '../../services/api';\nimport logoImg from '../../assets/images/logotipo.svg';\n//import Repository from '../Repository';\n\n// Essa interface é a definição dos tipos que existe na api publica do github\n/*9º*/interface Repository {\n  full_name: string;\n  description: string\n  owner: {\n    login: string;\n    avatar_url: string;\n  }\n}\n\nconst Dashboard: React.FC = () => {\n  /*3º*/const [newRepo, setNewRepo] = useState(''); // Estado para armazenar o valor do input\n  /*5º*/const [repositories, setRepositories] = useState<Repository[]>([])//Vai armazenar os repositórios usando o useState. Foi adicionado o <Repository[]> após o usState porque ele ta pegando o array de repositórios que o setRepositories ta recebendo.\n  /*12º*/ const [inputError, setInputError] = useState('')\n\n  /*18º*/ useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n\n  /*1º*/async function hundleAddRepository(event: FormEvent<HTMLFormElement>): Promise<void>{\n    //Adição de um novo repositŕoio\n    //Consumir a API do Github buscado\n    //Salvar novo respositório no estado\n    /* (event: FormEvent<HTMLFormElement>) junto com o event.preventDefault();\n    Previne o evento de recarregar a página sempre quando clica, nesse caso teve essa extenção maior porque o evento é no form, por isso, teve que importar o FormEvent tambem. Então foi passado um uma tipagem pronta nativo para formulário.\n    */\n   // async é significa função assicrona é necessário para trabalhar com a API.\n   // Quando a função passa a ser async é necessaŕio usar o Promise<void>\n\n    /*2º*/event.preventDefault();\n\n    /*13º*/ if (!newRepo) {\n      setInputError('Digite o autor/nome do repositório');\n     return;\n}\n /*14º*/  try {\n      // Chamada da API\n   /*4º*/ const response = await api.get<Repository>(`repos/${newRepo}`);\n\n    /*6º*/const repository = response.data; // repository está recebendo a informação do response, o response ta armazebando as informações da api. Já o data, seria as informações dos objetos.\n\n    //A API ta pegando os dados que ta armazenado em: ${newRepo} para assim ser inserido na pesquisa\n    // api.get(`repos/${newRepo}`) Em repos/ é a prévia fixa da URL de pesquisa\n    // O const repository são os dados que precisam ser adicionados ao fim da lista (Próxima etapa do projeto)\n    // Foi adicionado <Repository>, para pegar as informações baseadas na tipagem definina na interface Repository\n\n    /*7º*/setRepositories([...repositories, repository]);\n    /*11º*/ //Após clicar em pesquisar, o valor de pesquisa inserido no input permanece sendo exibido, para poder limpar e assim, ter uma expeciência mais agradavel de incluir uma nova pesquisa (valor), para isso, precisa chamar o estado nessa função. setNewRepo('');\n\n    setNewRepo('');\n    setInputError('');\n  } catch(error) {\n    setInputError('O autor/nome do repositório não existe');\n  }\n  }\n\n  /* No input, o valor que vai receber é o value={newRepo}\n  Quando o usuário altera o valor desse input, recebe um evento onChange={(e) => setNewRepo(e.target.value)}\n  */\n\n  /*10º*/ //Incluir as tipagens nas informações.\n\n  //No uso do map, foi adicionado o estado repositories que está recebendo um array e definindo um parametro, e no primeiro intem é importanten adicionar uma Key=\n\n\n/*** Tratamento de erros ***/\n\n/*12º*/ /*\nconst [inputError, setInputError] = useState('') Precisa ser criado um estado para o tratamento de erros. Foi criado como uma string ('') e não com True ou False porque pode ter mais de uma mensagem de erro.\n\n/*13º*/ /*\n  No inicio da função, será adicionado uma verificação, se o conteúdo da varivavel newRepo está vazio, o sinal de negação antes dele ja vai verificar. Então, newRpo vai receber o ustate setInputError com a seguinte mensagem... ('Digite o autor/nome do repositório')\n*/\n\n/*14º*/ /*\n  Todos os itens como:\n  -> const response = await api.get<Repository>(`repos/${newRepo}`);\n  -> const repository = response.data;\n  -> setRepositories([...repositories, repository]);\n  -> setNewRepo('');\n\n  Serão alocados para dentro de um Try. Se, a vaerificação do response falhar, será apresentado o erro em Catch. No caso optei em deixar catch(error) {seInputError('Erro na busca por esse repositório')}\n*/\n\n/*15º*/ /*\n  Foi criado um componente de estilo chamado {inputError && <Error>{inputError}</Error> }. Isso siginifca que se a variavel inputError ta preenchida, é mostrado o imput com a mensagem de erro e o component Error vai estilizar para ser exebido assim. O componente Error foi criado no style do componente Dashboard.\n*/\n\n/*16º*/ /*\n  O problema agora é que o erro ele não deixa de exibir após incluir um valor válido, o mesmo problema que teve para limpar o valor após digitado na pesquisa. Para isso não ocorrer, precisa adicionar o estado com uma string vazia.\n*/\n\n/*17º*/ /*\n  hasError={!!inputError} está recebendo a varivel/estado vazia. hasError não será reconhecido facilmente no form, por isso precisa ser aplicado diretamente na estilização do form uma prop pra ele. export const Form = styled.form<FormProps>`` e com isso criado uma interface chamada...\n\n  interface FormProps {\n  hasError: boolean;\n  }\n\nTambém precisa importar o {css}\nimport styled, {css} from 'styled-components';\n\nPara permitir o uso de CSS sentro das aspas ``, se não, não reconheceria o estilo dentro, ele entenderia como um texto simples.\n\nAgora é possivel criar um estilo especifico sempre que o status de erro aparecer conforme o objetivo dessa variavel.\n\n*/\n\n/*** LocalStorage ***/\n/*O objetivo do LocalStorage será para armazenar os repositórios após a pesquisa do repositório e manter exposto após atualizar a página, ja que sempre ao atualizar, não mostra mais  os repositórios pesquisados.\n*/\n\n/*18º*/ /*\n\n  Uma boa utilidade será o useEffect, ele permite que disparamos uma função sempre que uma varivel mudar.\n\n  Primeiro será importando import React, {useState, FormEvent, useEffect} from 'react';\n\n  Depois a declaração será colocada acima da função assicrona da seguinte forma.\n\n  useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', repositories);\n  }, [repositories]);\n\n  Onde ta '@GithubExplorer:repositories' foi a nomeação escolhida para identificar qual a aplicação que está sendo armazenada no Local Storange, é adicionado em uma string textual. Só que o LocalStorage não aceira Array e que o argumento do tipo repositories não possivel converter para string, para isso, é necessário converter o tipo para string: JSON.stringify(repositories)\n\n   useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n\n*/\n\n\n  return (\n    <>\n    <img src={logoImg} alt=\"Github Explorer\" />\n    <Title>Explore repositórios no Github</Title>\n\n    <Form hasError={!!inputError} onSubmit={hundleAddRepository}>\n      <input placeholder=\"Digite o nome do repositório\" value={newRepo} onChange={(e) => setNewRepo(e.target.value)}/>\n      <button type=\"submit\">\n        Pesquisar\n      </button>\n    </Form>\n  {inputError && <Error>{inputError}</Error> }\n    <Repositories>\n     {repositories.map(repository => (\n        <a key={repository.full_name} href=\"teste\">\n        <img src={repository.owner.avatar_url} alt={repository.owner.login}/>\n        <div>\n     <strong>{repository.full_name}</strong>\n      <p>{repository.description}</p>\n        </div>\n        <FiChevronRight size={20}/>\n      </a>\n     ))}\n    </Repositories>\n    </>\n  )\n}\n\nexport default Dashboard;\n"]},"metadata":{},"sourceType":"module"}