{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/home/pc/Documentos/github-repositorio-projeto/src/pages/Dashboard/index.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from 'react';\nimport { Title, Form, Repositories, Error } from './styles';\nimport { FiChevronRight } from 'react-icons/fi';\nimport api from '../../services/api';\nimport logoImg from \"../../assets/images/logotipo.svg\"; //import Repository from '../Repository';\n// Essa interface é a definição dos tipos que existe na api publica do github\n\n/*9º*/\n\nconst Dashboard = () => {\n  _s();\n\n  /*3º*/\n  const [newRepo, setNewRepo] = useState(''); // Estado para armazenar o valor do input\n\n  /*5º*/\n\n  /*19º*/\n\n  const [repositories, setRepositories] = useState(() => {\n    const storageRepositories = localStorage.getItem('@GithubExplorer:repositories');\n\n    if (storageRepositories) {\n      return JSON.parse(storageRepositories);\n    }\n\n    return [];\n  });\n  /*12º*/\n\n  const [inputError, setInputError] = useState('');\n  /*18º*/\n\n  useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n  /*1º*/\n\n  async function hundleAddRepository(event) {\n    //Adição de um novo repositŕoio\n    //Consumir a API do Github buscado\n    //Salvar novo respositório no estado\n\n    /* (event: FormEvent<HTMLFormElement>) junto com o event.preventDefault();\n    Previne o evento de recarregar a página sempre quando clica, nesse caso teve essa extenção maior porque o evento é no form, por isso, teve que importar o FormEvent tambem. Então foi passado um uma tipagem pronta nativo para formulário.\n    */\n    // async é significa função assicrona é necessário para trabalhar com a API.\n    // Quando a função passa a ser async é necessaŕio usar o Promise<void>\n\n    /*2º*/\n    event.preventDefault();\n    /*5º*/\n    //Vai armazenar os repositórios usando o useState. Foi adicionado o <Repository[]> após o usState porque ele ta pegando o array de repositórios que o setRepositories ta recebendo.\n\n    /*13º*/\n\n    if (!newRepo) {\n      setInputError('Digite o autor/nome do repositório');\n      return;\n    }\n    /*14º*/\n\n\n    try {\n      // Chamada da API\n\n      /*4º*/\n      const response = await api.get(`repos/${newRepo}`);\n      /*6º*/\n\n      const repository = response.data; // repository está recebendo a informação do response, o response ta armazebando as informações da api. Já o data, seria as informações dos objetos.\n      //A API ta pegando os dados que ta armazenado em: ${newRepo} para assim ser inserido na pesquisa\n      // api.get(`repos/${newRepo}`) Em repos/ é a prévia fixa da URL de pesquisa\n      // O const repository são os dados que precisam ser adicionados ao fim da lista (Próxima etapa do projeto)\n      // Foi adicionado <Repository>, para pegar as informações baseadas na tipagem definina na interface Repository\n\n      /*7º*/\n\n      setRepositories([...repositories, repository]);\n      /*11º*/\n      //Após clicar em pesquisar, o valor de pesquisa inserido no input permanece sendo exibido, para poder limpar e assim, ter uma expeciência mais agradavel de incluir uma nova pesquisa (valor), para isso, precisa chamar o estado nessa função. setNewRepo('');\n\n      setNewRepo('');\n      setInputError('');\n    } catch (error) {\n      setInputError('O autor/nome do repositório não existe');\n    }\n  }\n  /* No input, o valor que vai receber é o value={newRepo}\n  Quando o usuário altera o valor desse input, recebe um evento onChange={(e) => setNewRepo(e.target.value)}\n  */\n\n  /*10º*/\n  //Incluir as tipagens nas informações.\n  //No uso do map, foi adicionado o estado repositories que está recebendo um array e definindo um parametro, e no primeiro intem é importanten adicionar uma Key=\n\n  /*** Tratamento de erros ***/\n\n  /*12º*/\n\n  /*\n  const [inputError, setInputError] = useState('') Precisa ser criado um estado para o tratamento de erros. Foi criado como uma string ('') e não com True ou False porque pode ter mais de uma mensagem de erro.\n  /*13º*/\n\n  /*\n  No inicio da função, será adicionado uma verificação, se o conteúdo da varivavel newRepo está vazio, o sinal de negação antes dele ja vai verificar. Então, newRpo vai receber o ustate setInputError com a seguinte mensagem... ('Digite o autor/nome do repositório')\n  */\n\n  /*14º*/\n\n  /*\n  Todos os itens como:\n  -> const response = await api.get<Repository>(`repos/${newRepo}`);\n  -> const repository = response.data;\n  -> setRepositories([...repositories, repository]);\n  -> setNewRepo('');\n  Serão alocados para dentro de um Try. Se, a vaerificação do response falhar, será apresentado o erro em Catch. No caso optei em deixar catch(error) {seInputError('Erro na busca por esse repositório')}\n  */\n\n  /*15º*/\n\n  /*\n  Foi criado um componente de estilo chamado {inputError && <Error>{inputError}</Error> }. Isso siginifca que se a variavel inputError ta preenchida, é mostrado o imput com a mensagem de erro e o component Error vai estilizar para ser exebido assim. O componente Error foi criado no style do componente Dashboard.\n  */\n\n  /*16º*/\n\n  /*\n  O problema agora é que o erro ele não deixa de exibir após incluir um valor válido, o mesmo problema que teve para limpar o valor após digitado na pesquisa. Para isso não ocorrer, precisa adicionar o estado com uma string vazia.\n  */\n\n  /*17º*/\n\n  /*\n  hasError={!!inputError} está recebendo a varivel/estado vazia. hasError não será reconhecido facilmente no form, por isso precisa ser aplicado diretamente na estilização do form uma prop pra ele. export const Form = styled.form<FormProps>`` e com isso criado uma interface chamada...\n  interface FormProps {\n  hasError: boolean;\n  }\n  Também precisa importar o {css}\n  import styled, {css} from 'styled-components';\n  Para permitir o uso de CSS sentro das aspas ``, se não, não reconheceria o estilo dentro, ele entenderia como um texto simples.\n  Agora é possivel criar um estilo especifico sempre que o status de erro aparecer conforme o objetivo dessa variavel.\n  */\n\n  /*** LocalStorage ***/\n\n  /*O objetivo do LocalStorage será para armazenar algum dado de uma aplicação.\n  */\n\n  /*18º*/\n\n  /*\n  Uma boa utilidade será o useEffect. Nesse caso ele vai permitir que disparamos uma função sempre que uma varivel mudar.\n  Primeiro será importando import React, {useState, FormEvent, useEffect} from 'react';\n  Depois a declaração será colocada acima da função assicrona da seguinte forma.\n  useEffect(() => {\n  localStorage.setItem('@GithubExplorer:repositories', repositories);\n  }, [repositories]);\n  Onde ta '@GithubExplorer:repositories' foi a nomeação escolhida para identificar qual a aplicação que está sendo armazenada no Local Storange, é adicionado em uma string textual. Só que o LocalStorage não aceira Array e que o argumento do tipo repositories não possivel converter para string, para isso, é necessário converter o tipo para string: JSON.stringify(repositories)\n  useEffect(() => {\n  localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n  Agora os dados relacionado ao repositório será armezenado no LocalStorage\n  */\n\n  /*19º*/\n\n  /*\n  Os repositórios após a pesquisa do repositório precisa manter exposto ao atualizar a página, até o momento ao atualizar a página não mantem as ultimas pesquisas feitas.\n  Como o LocalStorage por ser uma API sicrona e é uma api que não precisa usar o async await (função assicrona), é possível trabalhar no lugar do array do repositório, usar uma função e dentro dessa função é possível escrever qualquer coisa, nesse caso, vai pegar os repositórios que estão no localstorage @GithubExplorer:repositories e vai ser passado a seguinte tomada de decisão:\n  const [repositories, setRepositories] = useState<Repository[]>(() => {\n  const storageRepositories = localStorage.getItem('@GithubExplorer:repositories'); //Pegando o valor do LocalStorage\n  if (storageRepositories)  {\n  return JSON.parse(storageRepositories); // Precisa agora desconverter de string para Array, por isso o uso do JSON.parse() e retornar como Array.\n  } return []; // Caso contrário return []; retorna um array vazio se não econtrar nada no LocalStorage.\n  });\n  */\n\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"img\", {\n      src: logoImg,\n      alt: \"Github Explorer\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 167,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(Title, {\n      children: \"Explore reposit\\xF3rios no Github\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 5\n    }, this), /*#__PURE__*/_jsxDEV(Form, {\n      hasError: !!inputError,\n      onSubmit: hundleAddRepository,\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        placeholder: \"Digite o nome do reposit\\xF3rio\",\n        value: newRepo,\n        onChange: e => setNewRepo(e.target.value)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        type: \"submit\",\n        children: \"Pesquisar\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 172,\n        columnNumber: 7\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 5\n    }, this), inputError && /*#__PURE__*/_jsxDEV(Error, {\n      children: inputError\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 176,\n      columnNumber: 18\n    }, this), /*#__PURE__*/_jsxDEV(Repositories, {\n      children: repositories.map(repository => /*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"teste\",\n        children: [/*#__PURE__*/_jsxDEV(\"img\", {\n          src: repository.owner.avatar_url,\n          alt: repository.owner.login\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 180,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n            children: repository.full_name\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 182,\n            columnNumber: 6\n          }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n            children: repository.description\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 183,\n            columnNumber: 7\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 181,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(FiChevronRight, {\n          size: 20\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 185,\n          columnNumber: 9\n        }, this)]\n      }, repository.full_name, true, {\n        fileName: _jsxFileName,\n        lineNumber: 179,\n        columnNumber: 9\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 5\n    }, this)]\n  }, void 0, true);\n};\n\n_s(Dashboard, \"U0fEDI43SExbOgJK+UDXMuHzdi8=\");\n\n_c = Dashboard;\nexport default Dashboard;\n\nvar _c;\n\n$RefreshReg$(_c, \"Dashboard\");","map":{"version":3,"sources":["/home/pc/Documentos/github-repositorio-projeto/src/pages/Dashboard/index.tsx"],"names":["React","useState","useEffect","Title","Form","Repositories","Error","FiChevronRight","api","Dashboard","newRepo","setNewRepo","repositories","setRepositories","storageRepositories","localStorage","getItem","JSON","parse","inputError","setInputError","setItem","stringify","hundleAddRepository","event","preventDefault","response","get","repository","data","error","logoImg","e","target","value","map","owner","avatar_url","login","full_name","description"],"mappings":"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","sourcesContent":["import React, {useState, FormEvent, useEffect} from 'react';\nimport {Title, Form, Repositories, Error} from './styles';\nimport {FiChevronRight} from 'react-icons/fi';\nimport api from '../../services/api';\nimport logoImg from '../../assets/images/logotipo.svg';\n//import Repository from '../Repository';\n\n// Essa interface é a definição dos tipos que existe na api publica do github\n/*9º*/interface Repository {\n  full_name: string;\n  description: string\n  owner: {\n    login: string;\n    avatar_url: string;\n  }\n}\n\nconst Dashboard: React.FC = () => {\n  /*3º*/const [newRepo, setNewRepo] = useState(''); // Estado para armazenar o valor do input\n  /*5º*/ /*19º*/const [repositories, setRepositories] = useState<Repository[]>(() => {\n  const storageRepositories = localStorage.getItem('@GithubExplorer:repositories');\n\n  if (storageRepositories)  {\n    return JSON.parse(storageRepositories);\n  }return [];\n});\n  /*12º*/ const [inputError, setInputError] = useState('')\n\n  /*18º*/ useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n\n  /*1º*/async function hundleAddRepository(event: FormEvent<HTMLFormElement>): Promise<void>{\n    //Adição de um novo repositŕoio\n    //Consumir a API do Github buscado\n    //Salvar novo respositório no estado\n    /* (event: FormEvent<HTMLFormElement>) junto com o event.preventDefault();\n    Previne o evento de recarregar a página sempre quando clica, nesse caso teve essa extenção maior porque o evento é no form, por isso, teve que importar o FormEvent tambem. Então foi passado um uma tipagem pronta nativo para formulário.\n    */\n   // async é significa função assicrona é necessário para trabalhar com a API.\n   // Quando a função passa a ser async é necessaŕio usar o Promise<void>\n\n    /*2º*/event.preventDefault();\n\n    /*5º*/ //Vai armazenar os repositórios usando o useState. Foi adicionado o <Repository[]> após o usState porque ele ta pegando o array de repositórios que o setRepositories ta recebendo.\n\n    /*13º*/ if (!newRepo) {\n      setInputError('Digite o autor/nome do repositório');\n     return;\n}\n /*14º*/  try {\n      // Chamada da API\n   /*4º*/ const response = await api.get<Repository>(`repos/${newRepo}`);\n\n    /*6º*/const repository = response.data; // repository está recebendo a informação do response, o response ta armazebando as informações da api. Já o data, seria as informações dos objetos.\n\n    //A API ta pegando os dados que ta armazenado em: ${newRepo} para assim ser inserido na pesquisa\n    // api.get(`repos/${newRepo}`) Em repos/ é a prévia fixa da URL de pesquisa\n    // O const repository são os dados que precisam ser adicionados ao fim da lista (Próxima etapa do projeto)\n    // Foi adicionado <Repository>, para pegar as informações baseadas na tipagem definina na interface Repository\n\n    /*7º*/setRepositories([...repositories, repository]);\n    /*11º*/ //Após clicar em pesquisar, o valor de pesquisa inserido no input permanece sendo exibido, para poder limpar e assim, ter uma expeciência mais agradavel de incluir uma nova pesquisa (valor), para isso, precisa chamar o estado nessa função. setNewRepo('');\n\n    setNewRepo('');\n    setInputError('');\n  } catch(error) {\n    setInputError('O autor/nome do repositório não existe');\n  }\n  }\n\n  /* No input, o valor que vai receber é o value={newRepo}\n  Quando o usuário altera o valor desse input, recebe um evento onChange={(e) => setNewRepo(e.target.value)}\n  */\n\n  /*10º*/ //Incluir as tipagens nas informações.\n\n  //No uso do map, foi adicionado o estado repositories que está recebendo um array e definindo um parametro, e no primeiro intem é importanten adicionar uma Key=\n\n\n/*** Tratamento de erros ***/\n\n/*12º*/ /*\nconst [inputError, setInputError] = useState('') Precisa ser criado um estado para o tratamento de erros. Foi criado como uma string ('') e não com True ou False porque pode ter mais de uma mensagem de erro.\n\n/*13º*/ /*\n  No inicio da função, será adicionado uma verificação, se o conteúdo da varivavel newRepo está vazio, o sinal de negação antes dele ja vai verificar. Então, newRpo vai receber o ustate setInputError com a seguinte mensagem... ('Digite o autor/nome do repositório')\n*/\n\n/*14º*/ /*\n  Todos os itens como:\n  -> const response = await api.get<Repository>(`repos/${newRepo}`);\n  -> const repository = response.data;\n  -> setRepositories([...repositories, repository]);\n  -> setNewRepo('');\n\n  Serão alocados para dentro de um Try. Se, a vaerificação do response falhar, será apresentado o erro em Catch. No caso optei em deixar catch(error) {seInputError('Erro na busca por esse repositório')}\n*/\n\n/*15º*/ /*\n  Foi criado um componente de estilo chamado {inputError && <Error>{inputError}</Error> }. Isso siginifca que se a variavel inputError ta preenchida, é mostrado o imput com a mensagem de erro e o component Error vai estilizar para ser exebido assim. O componente Error foi criado no style do componente Dashboard.\n*/\n\n/*16º*/ /*\n  O problema agora é que o erro ele não deixa de exibir após incluir um valor válido, o mesmo problema que teve para limpar o valor após digitado na pesquisa. Para isso não ocorrer, precisa adicionar o estado com uma string vazia.\n*/\n\n/*17º*/ /*\n  hasError={!!inputError} está recebendo a varivel/estado vazia. hasError não será reconhecido facilmente no form, por isso precisa ser aplicado diretamente na estilização do form uma prop pra ele. export const Form = styled.form<FormProps>`` e com isso criado uma interface chamada...\n\n  interface FormProps {\n  hasError: boolean;\n  }\n\nTambém precisa importar o {css}\nimport styled, {css} from 'styled-components';\n\nPara permitir o uso de CSS sentro das aspas ``, se não, não reconheceria o estilo dentro, ele entenderia como um texto simples.\n\nAgora é possivel criar um estilo especifico sempre que o status de erro aparecer conforme o objetivo dessa variavel.\n\n*/\n\n/*** LocalStorage ***/\n/*O objetivo do LocalStorage será para armazenar algum dado de uma aplicação.\n*/\n\n/*18º*/ /*\n\n  Uma boa utilidade será o useEffect. Nesse caso ele vai permitir que disparamos uma função sempre que uma varivel mudar.\n\n  Primeiro será importando import React, {useState, FormEvent, useEffect} from 'react';\n\n  Depois a declaração será colocada acima da função assicrona da seguinte forma.\n\n  useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', repositories);\n  }, [repositories]);\n\n  Onde ta '@GithubExplorer:repositories' foi a nomeação escolhida para identificar qual a aplicação que está sendo armazenada no Local Storange, é adicionado em uma string textual. Só que o LocalStorage não aceira Array e que o argumento do tipo repositories não possivel converter para string, para isso, é necessário converter o tipo para string: JSON.stringify(repositories)\n\n   useEffect(() => {\n    localStorage.setItem('@GithubExplorer:repositories', JSON.stringify(repositories));\n  }, [repositories]);\n\n  Agora os dados relacionado ao repositório será armezenado no LocalStorage\n\n*/\n\n/*19º*/ /*\nOs repositórios após a pesquisa do repositório precisa manter exposto ao atualizar a página, até o momento ao atualizar a página não mantem as ultimas pesquisas feitas.\n\nComo o LocalStorage por ser uma API sicrona e é uma api que não precisa usar o async await (função assicrona), é possível trabalhar no lugar do array do repositório, usar uma função e dentro dessa função é possível escrever qualquer coisa, nesse caso, vai pegar os repositórios que estão no localstorage @GithubExplorer:repositories e vai ser passado a seguinte tomada de decisão:\n\nconst [repositories, setRepositories] = useState<Repository[]>(() => {\n  const storageRepositories = localStorage.getItem('@GithubExplorer:repositories'); //Pegando o valor do LocalStorage\n\n  if (storageRepositories)  {\n    return JSON.parse(storageRepositories); // Precisa agora desconverter de string para Array, por isso o uso do JSON.parse() e retornar como Array.\n  } return []; // Caso contrário return []; retorna um array vazio se não econtrar nada no LocalStorage.\n});\n*/\n\n\n  return (\n    <>\n    <img src={logoImg} alt=\"Github Explorer\" />\n    <Title>Explore repositórios no Github</Title>\n\n    <Form hasError={!!inputError} onSubmit={hundleAddRepository}>\n      <input placeholder=\"Digite o nome do repositório\" value={newRepo} onChange={(e) => setNewRepo(e.target.value)}/>\n      <button type=\"submit\">\n        Pesquisar\n      </button>\n    </Form>\n  {inputError && <Error>{inputError}</Error> }\n    <Repositories>\n     {repositories.map(repository => (\n        <a key={repository.full_name} href=\"teste\">\n        <img src={repository.owner.avatar_url} alt={repository.owner.login}/>\n        <div>\n     <strong>{repository.full_name}</strong>\n      <p>{repository.description}</p>\n        </div>\n        <FiChevronRight size={20}/>\n      </a>\n     ))}\n    </Repositories>\n    </>\n  )\n}\n\nexport default Dashboard;\n"]},"metadata":{},"sourceType":"module"}